---
title: 'alexithymia_autism_coherence'
author: "Helio"
date: "2025-08-19"
output: html_document
---



some prep and cleanup
```{r}

# load("~/Library/CloudStorage/GoogleDrive-helioclemente.c@gmail.com/My Drive/Papers 2022/InteroceptionStudy/InteroStudy2020/analysis/DataAnalysisJanuary2020/DataAnalysisJan2020/2022_2023_Analyses/Data/EPS/EPS2024.RData")

dta_2023_eps
dta_2023_eps_nona_2
dta_2023_eps
colnames(dta_2023_eps)


setwd("~/Library/CloudStorage/GoogleDrive-helioclemente.c@gmail.com/My Drive/Papers 2022/InteroceptionStudy/InteroStudy2020/analysis/DataAnalysisJanuary2020/DataAnalysisJan2020/2022_2023_Analyses/Data/2025 - autism and alexithymia")
# just save key combined data
save(dta_2023_eps, dta_2023_eps_agg_sid, dta_2023_eps_nona, file = "dta_oxf_alex_aut_coherence.rdata")


load("~/Library/CloudStorage/GoogleDrive-helioclemente.c@gmail.com/My Drive/Papers 2022/InteroceptionStudy/InteroStudy2020/analysis/DataAnalysisJanuary2020/DataAnalysisJan2020/2022_2023_Analyses/Data/2025 - autism and alexithymia/dta_oxf_alex_aut_coherence.rdata")


library(readr)

unique(dta_iaps_fix_stim_joint2_nt4_jenny_rosie$ssid)
dta_iaps_fix_stim_joint2_nt4_jenny_rosie <- read_csv("dta_iaps_fix_stim_joint2_nt4_jenny_rosie.csv")
View(dta_iaps_fix_stim_joint2_nt4_jenny_rosie)

unique(dta_2023_eps$ssid)
# 7
# 
# 58*(64*2)
# 87*(64*2)

table(dta_2023_eps$ssid)
dta_2023_eps

require(tidyverse)

unique(dta_2023_eps$ssid)
unique(dta_2023_eps$stimiaps)

dta_2023_eps$stim
dta_2023_eps_no_dup<- dta_2023_eps %>%
  mutate(stimiaps3 = paste0(stimiaps2, stimdescription))%>%
  distinct(ssid, stimiaps3, tno, .keep_all = TRUE)
# number of particiants plus stim
# 87 *55# 4785
# we are ending up with this
# 4,290
# dta_iaps_fix_stim_joint2_nt4_jenny_rosie
table(dta_2023_eps_no_dup$ssid)


# dta_2023_eps_no_dup ismissing other questionnaires
```




21/08
- explore proper hierarchical PCA
- and by subject PCA
we will use this going forward
dta_2023_eps_no_dup


```{r}
dta_2023_eps_no_dup_cln<- dta_2023_eps_no_dup%>%
  janitor::clean_names()

dta_2023_eps_no_dup_cln
colnames(dta_2023_eps_no_dup_cln)
```


mixed models in specific signals
```{r}
dta_2023_eps_no_dup_cln


```

Alexithymia and autism influences on autonomic space

approach
- PCA one each subject
- store proportion explained by the first component and 
- number of components needed to explain 50% of the variance

```{r}


# Required packages
library(dplyr)
library(tidyr)
library(purrr)
library(rlang)

colnames(dta_2023_eps_no_dup_cln)
dta_2023_eps_no_dup_cln$pup_bascor
dta_2023_eps_no_dup_cln$mean_fix_dur
```


```{r}
# ----- settings -----

dta_2023_eps_no_dup_cln
dta_2023_eps_no_dup_cln<- dta_2023_eps_no_dup_cln%>%
  group_by(ssid)%>%
  mutate(
         bio_cda_phasicmax_log_z_sid = scale(log1p(bio_cda_phasicmax+.1)),
        bio_mean_hr_dif_z_sid = scale(bio_mean_hr_dif),
         valence_z_sid = scale(valence),
         arousal_z_sid = scale(arousal),
         pup_bascor_z_sid = scale(pup_bascor),
        mean_fix_dur_z_sid = scale(mean_fix_dur),
         )%>%
  ungroup()

# rm(vars)
vars_pca <- c( "bio_cda_phasicmax_log_z_sid","bio_mean_hr_dif_z_sid","pup_bascor_z_sid", "valence_z_sid", "arousal_z_sid")




table(is.na(dta_2023_eps_no_dup_cln$bio_cda_phasicmax_log_z_sid))
table(is.na(dta_2023_eps_no_dup_cln$bio_mean_hr_dif))
table(is.na(dta_2023_eps_no_dup_cln$pup_bascor_z_sid))
dta_2023_eps_no_dup_cln

unique(tmp_na$ssid)

table((tmp_na$ssid))



# 328
# 371


dta_2023_eps_no_dup_cln_no_na<- dta_2023_eps_no_dup_cln%>%
  
    subset(ssid!= 328)%>%
  subset(ssid!= 371)%>%
  subset(!is.na(tas_approx))%>%
  subset(!is.na(aq_approx)) 

table(dta_2023_eps_no_dup_cln_no_na$ssid)


table(dta_2023_eps_no_dup_cln_no_na$asd_sid)

table(dta_2023_eps_no_dup_cln_no_na$tas_med_split)

```




# Function: PCA metrics for one subject
also keep dimension scores
```{r}
# ---- packages ----
library(dplyr)
library(tidyr)
library(tibble)
library(janitor)
library(purrr)
# stats comes with base R (for prcomp, qlogis)

# ------------------------------------------------------------------
# pca_metrics_one():
#   - runs PCA on selected vars (no scaling)
#   - returns a one-row tibble with:
#       * `metrics`: a tibble of per-subject metrics (eigenvalues, props, logits…)
#       * `vardim`:  a tibble of per-variable x per-component measures:
#           loading, correlation, cos2, contribution
# ------------------------------------------------------------------
pca_metrics_one_2 <- function(df, eps = 1e-6) {
  X <- df %>%
    dplyr::select(dplyr::all_of(vars_pca)) %>%
    tidyr::drop_na()

  # helper for safe logit on [0,1] with NA passthrough
  safe_logit <- function(p) {
    ifelse(is.na(p), NA_real_,
           stats::qlogis(pmin(pmax(p, eps), 1 - eps)))
  }

  na_metrics <- tibble::tibble(
    eigen_pc1       = NA_real_,
    eigen_pc2       = NA_real_,
    eigen_pc3       = NA_real_,
    total_variance  = NA_real_,
    prop_pc1        = NA_real_,
    prop_pc2        = NA_real_,
    prop_pc3        = NA_real_,
    cumu_pc1_pc2    = NA_real_,
    cumu_pc1_to_pc3 = NA_real_,
    prop_pc1_logit        = NA_real_,
    prop_pc2_logit        = NA_real_,
    prop_pc3_logit        = NA_real_,
    cumu_pc1_pc2_logit    = NA_real_,
    cumu_pc1_to_pc3_logit = NA_real_,
    n_components_50 = NA_integer_
  )

  na_vardim <- tibble::tibble(
    variable = character(),
    dimension = integer(),
    loading = numeric(),
    correlation = numeric(),
    cos2 = numeric(),
    contribution = numeric()
  )

  if (nrow(X) < 2) {
    return(tibble::tibble(metrics = list(na_metrics), vardim = list(na_vardim)))
  }

  # keep original settings (no centering/scaling in prcomp)
  fit <- try(stats::prcomp(X, center = FALSE, scale. = FALSE), silent = TRUE)
  if (inherits(fit, "try-error")) {
    return(tibble::tibble(metrics = list(na_metrics), vardim = list(na_vardim)))
  }

  var_expl <- unname(fit$sdev^2)              # eigenvalues (variance explained)
  prop_var <- var_expl / sum(var_expl)        # proportions
  get_or_na <- function(v, i) if (length(v) >= i) v[i] else NA_real_

  # proportions & cumulatives
  prop1  <- get_or_na(prop_var, 1)
  prop2  <- get_or_na(prop_var, 2)
  prop3  <- get_or_na(prop_var, 3)
  cum12  <- if (length(prop_var) >= 2) sum(prop_var[1:2]) else prop1
  cum123 <- if (length(prop_var) >= 3) sum(prop_var[1:3]) else
              if (length(prop_var) >= 2) sum(prop_var[1:2]) else prop1

  metrics <- tibble::tibble(
    # eigenvalues (absolute variances)
    eigen_pc1       = get_or_na(var_expl, 1),
    eigen_pc2       = get_or_na(var_expl, 2),
    eigen_pc3       = get_or_na(var_expl, 3),
    total_variance  = sum(var_expl),

    # proportions
    prop_pc1        = prop1,
    prop_pc2        = prop2,
    prop_pc3        = prop3,
    cumu_pc1_pc2    = cum12,
    cumu_pc1_to_pc3 = cum123,

    # logit-transformed proportions
    prop_pc1_logit        = safe_logit(prop1),
    prop_pc2_logit        = safe_logit(prop2),
    prop_pc3_logit        = safe_logit(prop3),
    cumu_pc1_pc2_logit    = safe_logit(cum12),
    cumu_pc1_to_pc3_logit = safe_logit(cum123),

    # number of components to reach ≥ 50%
    n_components_50 = which(cumsum(prop_var) >= 0.50)[1]
  )

  # ---------------- variable–dimension measures ----------------
  # With prcomp(center=FALSE, scale.=FALSE), variable–PC correlation:
  #   corr_{j,k} = loading_{j,k} * sdev_k / sd(variable_j)
  # cos2 = corr^2
  # contribution (to component k) = corr_{j,k}^2 / sum_j corr_{j,k}^2

  # center X to get correct sd for each variable (mean affects corr, not sd)
  Xc <- scale(X, center = TRUE, scale = FALSE)
  sd_j <- apply(Xc, 2, stats::sd)
  sd_j[sd_j == 0] <- NA_real_

  loadings <- as.matrix(fit$rotation)   # p x K
  sdev <- fit$sdev                      # length K
  p <- nrow(loadings); K <- ncol(loadings)
  var_names <- rownames(loadings)
  if (is.null(var_names)) var_names <- colnames(X)

  # correlations p x K
  corr_mat <- sweep(loadings, 2, sdev, `*`)
  corr_mat <- sweep(corr_mat, 1, sd_j, `/`)

  cos2_mat <- corr_mat^2
  contrib_den <- colSums(cos2_mat, na.rm = TRUE)
  contrib_mat <- sweep(cos2_mat, 2, contrib_den, `/`)

  vardim <- tibble::tibble(
    variable     = rep(var_names, times = K),
    dimension    = rep(seq_len(K), each = p),
    loading      = as.vector(loadings),
    correlation  = as.vector(corr_mat),
    cos2         = as.vector(cos2_mat),
    contribution = as.vector(contrib_mat)
  )

  tibble::tibble(
    metrics = list(metrics),
    vardim  = list(vardim)
  )
}

# ------------------------------------------------------------------
# Apply per subject and build a single wide table:
#   - pca_subject_wide: one row per ssid, with metrics + per-variable columns
# ------------------------------------------------------------------

# set how many PCs to spread out as columns (change if you want more)
K_keep <- 3


# need to drop people beforehand

dta_2023_eps_no_dup_cln_no_na_4pca<- dta_2023_eps_no_dup_cln_no_na %>%
   dplyr::select(dplyr::all_of(vars_pca), ssid) %>%
    tidyr::drop_na()
length(unique(dta_2023_eps_no_dup_cln_no_na_4pca$ssid))

dta_2023_eps_no_dup_cln_no_na_4pca<-left_join(dta_2023_eps_no_dup_cln_no_na_4pca,
          dta_2023_eps_no_dup_cln_no_na)


pca_by_subject <- dta_2023_eps_no_dup_cln_no_na_4pca %>%
  dplyr::group_by(ssid) %>%
  dplyr::group_modify(~ pca_metrics_one_2(.x)) %>%
  dplyr::ungroup()
pca_by_subject

# one-row-per-subject metrics (your original summary)
pca_by_subject$vardim

pca_summary <- pca_by_subject %>%select(-vardim)%>% tidyr::unnest_wider(metrics)

pca_summary

pca_by_subject

# tidy variable–dimension table (per subject)
length(unique(pca_by_subject$ssid))
pca_vardim <- pca_by_subject %>% select(-metrics)%>% tidyr::unnest(vardim)
pca_vardim


# options(scipen = 999)
eps = 1e-6
fn_safe_fisher_z <- function(r) {
    r <- pmin(pmax(r, -1 + eps), 1 - eps)
    atanh(r)  
    }
    
pca_vardim%>%
    subset(dimension!= 4)%>%
  group_by(ssid,dimension )%>%
  select(ssid, variable, dimension,correlation,cos2,contribution)%>%
    subset(correlation>=-1)%>%
  ungroup()%>%
  mutate(cos2_logit = safe_logit(cos2),
         corr_f_z = fn_safe_fisher_z(correlation),
         contrib_logit = safe_logit(contribution))%>%
  ggplot(aes(cos2_logit, cos2))+
  geom_point()


pca_vardim%>%
    subset(dimension!= 4)%>%
  group_by(ssid,dimension )%>%
  select(ssid, variable, dimension,correlation,cos2,contribution)%>%
  ungroup()%>%
    subset(correlation>=-1)%>%
  mutate(cos2_logit = safe_logit(cos2),
         corr_f_z = fn_safe_fisher_z(correlation),
         contrib_logit = safe_logit(contribution))%>%
  ggplot(aes(contrib_logit, contribution))+
  geom_point()


pca_vardim%>%
    subset(dimension!= 4)%>%
  group_by(ssid,dimension )%>%
  select(ssid, variable, dimension,correlation,cos2,contribution)%>%
  subset(correlation>=-1)%>%
  ungroup()%>%
  mutate(cos2_logit = safe_logit(cos2),
         corr_f_z = fn_safe_fisher_z(correlation),
         contrib_logit = safe_logit(contribution))%>%
  ggplot(aes(corr_f_z, correlation))+
  geom_point()


range(pca_vardim$correlation)


```
  



```{r}

pca_vardim%>%
    subset(dimension!= 4)%>%
  group_by(ssid,dimension )%>%
  select(ssid, variable, dimension,correlation,cos2,contribution)%>%
    subset(correlation>=-1)%>%
  ungroup()%>%
  ungroup()%>%
  mutate(cos2_logit = safe_logit(cos2),
         corr_f_z = fn_safe_fisher_z(correlation),
         contrib_logit = safe_logit(contribution))
   
pca_vardim_agg<-

pca_vardim%>%
    subset(dimension< 4)%>%
    select(ssid, variable, dimension,correlation, cos2,contribution)%>%
  group_by(ssid,dimension )%>%
    mutate(cos2_logit = safe_logit(cos2),
         corr_f_z = fn_safe_fisher_z(correlation),
         contrib_logit = safe_logit(contribution))%>%
  group_by(ssid, dimension,variable)%>%
  summarise_if(is.numeric, mean, na.rm = T)
  ungroup()%>%
  

# why is contribution constant across subjects: because uits a paret variable
  
pca_vardim_agg
```


```{r}
# pivot per-variable measures into columns and join to metrics

pca_varcols_wide 


pca_vardim_agg_wid<- pca_vardim_agg %>%
  dplyr::filter(dimension <= K_keep) %>%
  # dplyr::mutate(variable = janitor::make_clean_names(variable)) %>%
  tidyr::pivot_wider(
    id_cols = ssid,
    names_from = c(dimension),
    values_from = c(cos2, contribution, cos2_logit,contrib_logit ),
    names_glue = "{.value}_PC{dimension}"
  )

length(unique(dta_vars_4pca$ssid))

length(unique(pca_vardim_agg_wid$ssid))
```




Approach 2
- the approach above needs aligning dimensions, etc
- Global PCA then project each individual and derive metrics


```{r}

# install.packages("tidyverse")
# install.packages("FactoMineR")
# install.packages("factoextra")

require(tidyverse)
require(FactoMineR)

require(factoextra)


setwd("~/Library/CloudStorage/GoogleDrive-helioclemente.c@gmail.com/My Drive/Papers 2022/InteroceptionStudy/InteroStudy2020/analysis/DataAnalysisJanuary2020/DataAnalysisJan2020/2022_2023_Analyses/Data/2025 - autism and alexithymia")

colnames(dta_2023_eps_no_dup_cln_no_na_4pca)
dta_vars_4pca<- dta_2023_eps_no_dup_cln_no_na_4pca%>%
    dplyr::select(dplyr::all_of(vars_pca), ssid) %>%
    tidyr::drop_na()


dta_vars_4pca
# don't scale here as the data is already scaled by SID
require(FactoMineR)
??FactoMineR::PCA


colnames(dta_vars_4pca)

pca_long_k5<- FactoMineR::PCA(dta_vars_4pca, scale.unit = FALSE,
                ncp = 5)

fviz_screeplot(pca_long_k5, ncp=5)
?fviz_contrib
fviz_pca_contrib(pca_long_k5, "var", axes = 1)
fviz_pca_contrib(pca_long_k5, "var", axes = 2)
fviz_pca_contrib(pca_long_k5, "var", axes = 3)
fviz_pca_contrib(pca_long_k5, "var", axes = 4)

# okay lets keep the first 2

pca_long_k2<- FactoMineR::PCA(dta_vars_4pca, scale.unit = FALSE,
                ncp = 3)

fviz_screeplot(pca_long_k5, ncp=2)

?fviz_contrib

fviz_pca_contrib(pca_long_k5, "var", axes = 1)
fviz_pca_contrib(pca_long_k5, "var", axes = 2)
fviz_pca_contrib(pca_long_k5, "var", axes = 3)
fviz_pca_contrib(pca_long_k5, "var", axes = 4)
# keep 3

pca_long_k3<- FactoMineR::PCA(dta_vars_4pca[,1:5], scale.unit = FALSE,
                ncp = 3)

fviz_screeplot(pca_long_k5, ncp=3)

?fviz_contrib

fviz_pca_contrib(pca_long_k5, "var", axes = 1)
fviz_pca_contrib(pca_long_k5, "var", axes = 2)
fviz_pca_contrib(pca_long_k5, "var", axes = 3)
fviz_pca_contrib(pca_long_k5, "var", axes = 4)

# okay lets do MFA 

pca_long_k3<- FactoMineR::PCA(dta_vars_4pca, scale.unit = FALSE,
                ncp = 3)

fviz_screeplot(pca_long_k5, ncp=3)

?fviz_contrib

fviz_pca_contrib(pca_long_k3, "var", axes = 1)
fviz_pca_contrib(pca_long_k3, "var", axes = 2)
fviz_pca_contrib(pca_long_k3, "var", axes = 3)


colnames(dta_vars_4pca)
mod_res<- list() 

# this one is not really informative, its the same as PCA theorethically

mod_res$mfa_long_k3 <- MFA(dta_vars_4pca[,1:5],
                           group=c(1,1,1,1,1),
                           type=c("s","s","s","s","s"),
                           name.group=c("scr","hr","pup", "val","arousal"),
                           # num.group.sup=c(1),
                           ncp = 3,
                           graph=TRUE)


fviz_pca_contrib(pca_long_k3, "var", axes = 1)
fviz_pca_contrib(pca_long_k3, "var", axes = 2)
fviz_pca_contrib(pca_long_k3, "var", axes = 3)
fviz_contrib(mod_res$mfa_long_k3, "quanti.var", axes = 1)
fviz_contrib(mod_res$mfa_long_k3, "quanti.var", axes = 2)
fviz_contrib(mod_res$mfa_long_k3, "quanti.var", axes = 3)


# vs group subjective and physilogical

mod_res$mfa_long_k3_2grps <- MFA(dta_vars_4pca[,1:5],
                                 # MFA(dta_vars_4pca[,c(1:2, 4:5)],
                                    # group=c(2,2),
                           group=c(3,2),
                           type=c("s","s"),
                           name.group=c("physio","subjective"),
                           # num.group.sup=c(1),
                           ncp = 3,
                           graph=TRUE)


fviz_contrib(mod_res$mfa_long_k3_2grps, "quanti.var", axes = 1)
fviz_contrib(mod_res$mfa_long_k3_2grps, "quanti.var", axes = 2)
fviz_contrib(mod_res$mfa_long_k3_2grps, "quanti.var", axes = 3)

# okay, now lets project each individual do thimfa_long_k3_2grps and derive metrics like variance for weach dimension etc
dta_vars_4pca$ssid

mod_res$mfa_long_k3_2grps$ind$coord.partiel
mod_res$mfa_long_k3_2grps$ind$within.partial.inertia

test<- as.data.frame(mod_res$mfa_long_k3_2grps$ind$coord.partiel)

test$phys_subj <- rownames(test)

test<- as.data.frame(test)%>%
  mutate(phys_subj = sub("^[0-9]+\\.", "", phys_subj))


phys_part<- as.data.frame(test)%>%
  subset(phys_subj == "physio")

subj_part<- as.data.frame(test)%>%
  subset(phys_subj != "physio")

# 7708/2 = 3854

coh_trial <- sqrt(rowSums((phys_part[,1:3] - subj_part[,1:3])^2))


dta_trial <- data.frame(
  ssid = dta_vars_4pca$ssid,
  coh  = coh_trial
)

library(dplyr)

dta_tria_coh_ssid <- dta_trial %>%
  group_by(ssid) %>%
  summarise(
    mean_coh = mean(coh, na.rm = TRUE),
    sd_coh   = sd(coh, na.rm = TRUE),
    n_trials = n()
  )



dta_2023_eps_agg_sid

dta_2023_eps_no_dup_cln_no_na_agg<- dta_2023_eps_no_dup_cln_no_na%>%
  group_by(ssid, tas_med_split, aq_med_split,asd_sid)%>%
  summarise_if(is.numeric, mean, na.rm = T)

dta_tria_coh_ssid%>%
  left_join(dta_2023_eps_agg_sid)

dta_tria_coh_ssid%>%
  ggplot(aes(x = mean_coh))+
  geom_histogram()




dta_tria_coh_ssid%>%
  left_join(dta_2023_eps_no_dup_cln_no_na_agg)%>%
    ggplot(aes(x = mean_coh, colour = tas_med_split))+
  geom_histogram()+
  facet_grid(~asd_sid)

dta_tria_coh_ssid%>%
  left_join(dta_2023_eps_no_dup_cln_no_na_agg)%>%
    ggplot(aes(x = mean_coh, colour = aq_med_split))+
  geom_histogram()+
  facet_grid(~asd_sid)


dta_tria_coh_ssid%>%
  left_join(dta_2023_eps_no_dup_cln_no_na_agg)%>%
  subset(ssid!= 605)%>%
    ggplot(aes(x = mean_coh, tas_approx_z))+
  geom_point()+
  geom_text(aes(label = ssid))+
  geom_smooth(method = "lm" )+
  # facet_grid(~asd_sid)+
      ggpubr::stat_cor()


dta_tria_coh_ssid%>%
  left_join(dta_2023_eps_no_dup_cln_no_na_agg)%>%
    ggplot(aes(x = mean_coh, aq))+
  geom_point()+
  geom_smooth(method = "lm" )+
    ggpubr::stat_cor()


# check mixed models
mfa_long_k3_2grps


dta_2023_eps_no_dup_cln_no_na_4pca
dta_vars_4pca$mfa_pc1_coord<- mod_res$mfa_long_k3_2grps$ind$coord[,1]
dta_vars_4pca$mfa_pc2_coord<- mod_res$mfa_long_k3_2grps$ind$coord[,2]
dta_vars_4pca$mfa_pc3_coord<- mod_res$mfa_long_k3_2grps$ind$coord[,3]

dta_vars_4pca$mfa_pc1_contrib<- mod_res$mfa_long_k3_2grps$ind$contrib[,1]
dta_vars_4pca$mfa_pc2_contrib<- mod_res$mfa_long_k3_2grps$ind$contrib[,2]
dta_vars_4pca$mfa_pc3_contrib<- mod_res$mfa_long_k3_2grps$ind$contrib[,3]

colnames(dta_2023_eps_no_dup_cln_no_na_4pca)

dta_vars_4pca%>%
  left_join(dta_2023_eps_no_dup_cln_no_na_4pca)%>%
  group_by(ssid, tas_med_split, aq_med_split)%>%
  summarise_if(is.numeric, mean, na.rm = T)%>%
  ggplot(aes(tas_med_split, mfa_pc1_coord))+
  geom_jitter(width = .1, alpha = .1)+
  stat_summary(geom = "pointrange")

dta_vars_4pca%>%
  left_join(dta_2023_eps_no_dup_cln_no_na_4pca)%>%
  group_by(ssid, tas_med_split, aq_med_split)%>%
  summarise_if(is.numeric, mean, na.rm = T)%>%
  ggplot(aes(tas_med_split, mfa_pc2_coord))+
  geom_jitter(width = .1, alpha = .1)+
  stat_summary(geom = "pointrange")

dta_vars_4pca%>%
  left_join(dta_2023_eps_no_dup_cln_no_na_4pca)%>%
  group_by(ssid, tas_med_split, aq_med_split)%>%
  summarise_if(is.numeric, mean, na.rm = T)%>%
  ggplot(aes(tas_med_split, mfa_pc3_coord))+
  geom_jitter(width = .1, alpha = .1)+
  stat_summary(geom = "pointrange")

install.packages("lmerTest")
# insta
require(lmerTest)

 dta_vars_4pca_2<- dta_vars_4pca%>%
  left_join(dta_2023_eps_no_dup_cln_no_na_4pca)

mod_res$lmer_mfa_coord<- lmer(mfa_pc3_coord ~ tas_approx_z + (1|stimiaps), REML = FALSE,
     dta_vars_4pca_2)
anova(mod_res$lmer_mfa_coord)
mod_res$lmer_mfa_coord_aq<- lmer(mfa_pc1_coord ~ aq2_approx_z + (1|stimiaps), REML = FALSE,
     dta_vars_4pca_2)

anova(mod_res$lmer_mfa_coord)
anova(mod_res$lmer_mfa_coord_aq)

mod_res$lmer_mfa_cntrb <- lmer(mfa_pc3_contrib ~ tas_approx_z + (1|ssid)+ (1|stimiaps), REML = FALSE,
     dta_vars_4pca_2)

anova(mod_res$lmer_mfa_cntrb )

mod_res$lmer_mfa_cntrb_aq<- lmer(mfa_pc1_contrib ~ aq2_approx_z + (1|ssid)+ (1|stimiaps), REML = FALSE,
     dta_vars_4pca_2)

anova(mod_res$lmer_mfa_cntrb_aq )



```
  # facet_grid(~asd_sid)


# install.packages("ggside")
# install.packages("ggpubr")

```{r}
dta_tria_coh_ssid%>%
  left_join(dta_2023_eps_no_dup_cln_no_na_agg)%>%
    ggplot(aes(x = tas_med_split, y = log1p(mean_coh+.1), colour = tas_med_split))+
  # geom_jitter(aes(shape = asd_sid), width = .1)+
  stat_summary(geom = "pointrange")+

  ggside::geom_ysidedensity()+
  ggpubr::stat_compare_means()


dta_tria_coh_ssid%>%
  left_join(dta_2023_eps_no_dup_cln_no_na_agg)%>%
    ggplot(aes(x = aq_med_split, y = log1p(mean_coh+.1), colour =aq_med_split ))+
  # geom_jitter(aes(shape = asd_sid), width = .1)+
  stat_summary(geom = "pointrange")+

  ggside::geom_ysidedensity()+
  ggpubr::stat_compare_means()
  
```
    



“How much of a subject’s variability lies along dimension 1, 2, 3…?”

You already have each trial’s coordinates:

```{r}
scores<-  mod_res$mfa_long_k3_2grps$ind$coord   # trials × dimensions

dta_scores <- cbind(ssid = dta_vars_4pca$ssid, as.data.frame(scores))
library(dplyr)

dta_var_by_sid <- dta_scores %>%
  group_by(ssid) %>%
  summarise(across(starts_with("Dim"),
                   ~var(.x, na.rm = TRUE),
                   .names = "var_{col}"))

dta_var_by_sid <- dta_var_by_sid %>%
  mutate(total = var_Dim.1 + var_Dim.2 + var_Dim.3,
         p1 = var_Dim.1 / total,
         p2 = var_Dim.2 / total,
         p3 = var_Dim.3 / total)


dta_var_by_sid%>%
  ggplot(aes(x = var_Dim.1))+
  geom_histogram()




dta_var_by_sid%>%
  left_join(dta_2023_eps_no_dup_cln_no_na_agg)%>%
  subset(var_Dim.1> 0.75)%>%
    ggplot(aes(x = tas_med_split, y = (var_Dim.1), colour = tas_med_split))+
  geom_jitter(aes(shape = asd_sid), width = .1)+
  stat_summary(geom = "pointrange")+

  ggside::geom_ysidedensity()+
  ggpubr::stat_compare_means()


dta_var_by_sid%>%
  left_join(dta_2023_eps_no_dup_cln_no_na_agg)%>%
    ggplot(aes(x = aq_med_split, y = (var_Dim.1), colour =aq_med_split ))+
  geom_jitter(aes(shape = asd_sid), width = .1)+
  stat_summary(geom = "pointrange")+

  ggside::geom_ysidedensity()+
  ggpubr::stat_compare_means()
```


use the score

```{r}

mod_res$mfa_long_k3_2grps$eig


mod_res$mfa_long_k3_2grps$ind$cos2
mod_res$mfa_long_k3_2grps$ind$contrib
mod_res$mfa_long_k3_2grps$ind$coord


dta_cos<- as.data.frame(mod_res$mfa_long_k3_2grps$ind$cos2)

names(dta_cos)<- paste0(colnames(dta_cos), "_cos")

bind_cols(dta_cos,dta_2023_eps_no_dup_cln_no_na_4pca)%>%
  group_by(ssid, tas_med_split)%>%
  summarise_if(is.numeric, mean, na.rm = T)%>%
  
    ggplot(aes(x = tas_med_split, y = (Dim.1_cos), colour = tas_med_split))+
  # geom_jitter(aes(shape = asd_sid), width = .1)+
  stat_summary(geom = "pointrange")+

  ggside::geom_ysidedensity()+
  ggpubr::stat_compare_means()





bind_cols(dta_cos,dta_2023_eps_no_dup_cln_no_na_4pca)%>%
  group_by(ssid, tas_med_split)%>%
  summarise_if(is.numeric, mean, na.rm = T)%>%
  
    ggplot(aes(x = tas_med_split, y = (Dim.2_cos), colour = tas_med_split))+
  # geom_jitter(aes(shape = asd_sid), width = .1)+
  stat_summary(geom = "pointrange")+

  ggside::geom_ysidedensity()+
  ggpubr::stat_compare_means()



  
bind_cols(dta_cos,dta_2023_eps_no_dup_cln_no_na_4pca)%>%
  group_by(ssid, tas_med_split)%>%
  summarise_if(is.numeric, mean, na.rm = T)%>%
  
    ggplot(aes(x = tas_med_split, y = (Dim.3_cos), colour = tas_med_split))+
  # geom_jitter(aes(shape = asd_sid), width = .1)+
  stat_summary(geom = "pointrange")+

  ggside::geom_ysidedensity()+
  ggpubr::stat_compare_means()

# coord and contrib
mod_res$mfa_long_k3_2grps$ind$cos2

dmod_res$mfa_long_k3_2grps$ind$contrib

dta_contrib <- as.data.frame(mod_res$mfa_long_k3_2grps$ind$contrib)
names(dta_contrib) <- paste0(colnames(dta_contrib), "_contrib")

bind_cols(dta_contrib, dta_2023_eps_no_dup_cln_no_na_4pca) %>%
  group_by(ssid, tas_med_split) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE) %>%
  ggplot(aes(x = tas_med_split, y = Dim.1_contrib, colour = tas_med_split)) +
  stat_summary(geom = "pointrange") +
  ggside::geom_ysidedensity() +
  ggpubr::stat_compare_means()

bind_cols(dta_contrib, dta_2023_eps_no_dup_cln_no_na_4pca) %>%
  group_by(ssid, tas_med_split) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE) %>%
  ggplot(aes(x = tas_med_split, y = Dim.2_contrib, colour = tas_med_split)) +
  stat_summary(geom = "pointrange") +
  ggside::geom_ysidedensity() +
  ggpubr::stat_compare_means()

bind_cols(dta_contrib, dta_2023_eps_no_dup_cln_no_na_4pca) %>%
  group_by(ssid, tas_med_split) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE) %>%
  ggplot(aes(x = tas_med_split, y = Dim.3_contrib, colour = tas_med_split)) +
  stat_summary(geom = "pointrange") +
  ggside::geom_ysidedensity() +
  ggpubr::stat_compare_means()

# 

mod_res$mfa_long_k3_2grps$ind$coord

dta_coord <- as.data.frame(mod_res$mfa_long_k3_2grps$ind$coord)
names(dta_coord) <- paste0(colnames(dta_coord), "_coord")

bind_cols(dta_coord, dta_2023_eps_no_dup_cln_no_na_4pca) %>%
  # group_by(ssid, tas_med_split) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE) %>%
  ggplot(aes(x = tas_med_split, y = Dim.1_coord, colour = tas_med_split)) +
  stat_summary(geom = "pointrange") +
  ggside::geom_ysidedensity() +
  ggpubr::stat_compare_means()

bind_cols(dta_coord, dta_2023_eps_no_dup_cln_no_na_4pca) %>%
  group_by(ssid, tas_med_split) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE) %>%
  ggplot(aes(x = tas_med_split, y = Dim.2_coord, colour = tas_med_split)) +
  stat_summary(geom = "pointrange") +
  ggside::geom_ysidedensity() +
  ggpubr::stat_compare_means()

bind_cols(dta_coord, dta_2023_eps_no_dup_cln_no_na_4pca) %>%
  group_by(ssid, tas_med_split) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE) %>%
  ggplot(aes(x = tas_med_split, y = Dim.3_coord, colour = tas_med_split)) +
  stat_summary(geom = "pointrange") +
  ggside::geom_ysidedensity() +
  ggpubr::stat_compare_means()


```


```{r}
# final table: metrics + per-variable columns
pca_subject_wide <- pca_summary_2[,1:16] %>%
  dplyr::left_join(pca_vardim_agg_wid, by = "ssid")



pca_subject_wide%>%
  ggplot(aes(ssid, cos2_PC1_))+
  geom_point()


pca_subject_wide%>%
  ggplot(aes(ssid, cos2_logit_PC1))+
  geom_point()

# is.na(dta_2023_eps_no_dup_cln_no_na$tas)
dta_2023_eps_no_dup_cln_no_na%>%
left_join(pca_subject_wide)%>%
  subset(!is.na(tas))%>%
  mutate(tas_med_split = if_else(tas> median(tas), "high", "low"))%>%
  group_by(ssid, tas_med_split)%>%
  summarise_if(is.numeric, mean, na.rm = T)%>%
  ggplot(aes(tas_med_split, cos2_PC1, colour = tas_med_split))+
  geom_jitter(width = .1, alpha = .2)+
  stat_summary(geom = "pointrange")+

   ggside::geom_ysidedensity(
    aes(x = after_stat(density),fill = tas_med_split),       # density of PC1
    position = "identity",
    alpha    = 0.3,
    size     = 0,
    adjust   = 1.2,                     # smoothing
    show.legend = FALSE)+
  scale_fill_brewer(palette = "Dark2")+
   scale_colour_brewer(palette = "Dark2")+
  ggpubr::stat_compare_means()
  # )+ 


dta_2023_eps_no_dup_cln_no_na%>%
left_join(pca_subject_wide)%>%
  subset(!is.na(tas))%>%
  mutate(tas_med_split = if_else(tas> median(tas), "high", "low"))%>%
  group_by(ssid, tas_med_split)%>%
  summarise_if(is.numeric, mean, na.rm = T)%>%
  ggplot(aes(tas_med_split, cos2_PC2, colour = tas_med_split))+
  geom_jitter(width = .1, alpha = .2)+
  stat_summary(geom = "pointrange")+

   ggside::geom_ysidedensity(
    aes(x = after_stat(density),fill = tas_med_split),       # density of PC1
    position = "identity",
    alpha    = 0.3,
    size     = 0,
    adjust   = 1.2,                     # smoothing
    show.legend = FALSE)+
  scale_fill_brewer(palette = "Dark2")+
   scale_colour_brewer(palette = "Dark2")+
  ggpubr::stat_compare_means()





dta_2023_eps_no_dup_cln_no_na%>%
left_join(pca_subject_wide)%>%
  subset(!is.na(tas))%>%
  mutate(tas_med_split = if_else(tas> median(tas), "high", "low"))%>%
  group_by(ssid, tas_med_split)%>%
  summarise_if(is.numeric, mean, na.rm = T)%>%
  ggplot(aes(tas_med_split, cos2_PC3, colour = tas_med_split))+
  geom_jitter(width = .1, alpha = .2)+
  stat_summary(geom = "pointrange")+

   ggside::geom_ysidedensity(
    aes(x = after_stat(density),fill = tas_med_split),       # density of PC1
    position = "identity",
    alpha    = 0.3,
    size     = 0,
    adjust   = 1.2,                     # smoothing
    show.legend = FALSE)+
  scale_fill_brewer(palette = "Dark2")+
   scale_colour_brewer(palette = "Dark2")+
  ggpubr::stat_compare_means(method = "t.test")

```



one row one subject analysis
MFA

```{r}
colnames(dta_2023_eps_no_dup_cln_no_na_4pca)


dta_2023_eps_no_dup_cln_no_na_4pca

dta_2023_eps_no_dup_cln_no_na_4pca
dta_vars_4mfa_2<- dta_2023_eps_no_dup_cln_no_na_4pca%>%
    dplyr::select(dplyr::all_of(vars_pca), ssid,stimiaps2,arousal,valence,bio_mean_hr_dif,pup_bascor,bio_cda_phasicmax,
                 tas,aq, tas_approx_z,aq2_approx_z,tas_med_split,aq_med_split,asd_sid,valencemean,arousalmean)

# length(unique(dta_vars_4mfa_2$ssid))

dta_vars_4mfa_2_wide <- dta_vars_4mfa_2 %>%
  pivot_wider(
    id_cols = c(ssid, tas, aq,tas_approx_z , aq2_approx_z,tas_med_split,aq_med_split, asd_sid),
    names_from = stimiaps2,
    values_from = matches("z_sid|hr|cda|pup|valence|arousal")
  )

table(dta_vars_4mfa_2$ssid)

dta_vars_4mfa_2_wide
```


just for MFA
```{r}
# complete the daatset gvia imputation
colnames(dta_vars_4mfa_2_wide)
dta_vars_4mfa_2_wide_sel<- dta_vars_4mfa_2_wide[,c(1,4:8,9:358)]

colnames(dta_vars_4mfa_2_wide_sel)
colnames(dta_vars_4mfa_2_wide_sel[,c(7:256)])
install.packages("missMDA")

dta_vars_4mfa_2_wide_sel_complet <- missMDA::imputeMFA(dta_vars_4mfa_2_wide_sel[,c(7:256)],
                                               ncp=2,
                                               group=c(50,50,50,50,50),
                                        type=c( "s","s","s","s","s"))


# dta_vars_4mfa_2_wide_sel_complet<- bind_cols(dta_vars_4mfa_2_wide_sel[,1:6], 
# dta_vars_4mfa_2_wide_sel_complet$completeObs)
# 
# dta_vars_4mfa_2_wide_sel_complet
# colnames(dta_vars_4mfa_2_wide_sel_complet)
```

mfa
```{r}

dta_vars_4mfa_2_wide_sel_complet

dta_vars_4mfa_2_wide_sel_complet
require(FactoMineR)

mod_res$mfa_z_sid<- FactoMineR::MFA(dta_vars_4mfa_2_wide_sel[,c(7:256)],
             tab.comp=dta_vars_4mfa_2_wide_sel_complet,
              group=c(50,50,50,50,50),
             # type=c( "c","c","c","c","c"),
              type=c("s","s","s","s","s"),
             name.group=c( "scr","hr","pupil","valence","arousal"),
             ncp = 3,
             # num.group.sup=c(1,2),
             graph=TRUE)

mod_res$mfa_z_sid

plot.MFA(resMFA_justvars)


# correlation circle
plot.MFA(mod_res$mfa_z_sid, choix="var",
         select='cos2 0.45',
         habillage='group',
         title="Correlation circle",
         cex=1.5,
         cex.main=0.8,
         cex.axis=0.8)






```


```{r}
mod_res$mfa_z_sid

fviz_screeplot(mod_res$mfa_z_sid, ncp=5)

fviz_contrib(mod_res$mfa_z_sid, "quanti.var", axes = 1, top = 10)
fviz_contrib(mod_res$mfa_z_sid, "quanti.var", axes = 2,top = 10)
fviz_contrib(mod_res$mfa_z_sid, "quanti.var", axes = 3,top = 10)


dta_vars_4mfa_2_wide_sel$mfa_z_sid_coord_1<- mod_res$mfa_z_sid$ind$coord[,1]
dta_vars_4mfa_2_wide_sel$mfa_z_sid_coord_2<- mod_res$mfa_z_sid$ind$coord[,2]
dta_vars_4mfa_2_wide_sel$mfa_z_sid_coord_3<- mod_res$mfa_z_sid$ind$coord[,3]

dta_vars_4mfa_2_wide_sel$mfa_z_sid_cos2_1<- mod_res$mfa_z_sid$ind$cos2[,1]
dta_vars_4mfa_2_wide_sel$mfa_z_sid_cos2_2<- mod_res$mfa_z_sid$ind$cos2[,2]
dta_vars_4mfa_2_wide_sel$mfa_z_sid_cos2_3<- mod_res$mfa_z_sid$ind$cos2[,3]

dta_vars_4mfa_2_wide_sel$mfa_z_sid_contrib_1<- mod_res$mfa_z_sid$ind$contrib[,1]
dta_vars_4mfa_2_wide_sel$mfa_z_sid_contrib_2<- mod_res$mfa_z_sid$ind$contrib[,2]
dta_vars_4mfa_2_wide_sel$mfa_z_sid_contrib_3<- mod_res$mfa_z_sid$ind$contrib[,3]
```


```{r}
# correlation with dimensiuon 1
dta_vars_4mfa_2_wide_sel%>%
  ggplot(aes(tas_approx_z,mfa_z_sid_coord_1 ))+
  geom_point()+
  ggpubr::stat_cor()+
  geom_smooth(method = "lm")


dta_vars_4mfa_2_wide_sel%>%
  ggplot(aes(aq2_approx_z,mfa_z_sid_coord_1 ))+
  geom_point()+
  ggpubr::stat_cor()+
  geom_smooth(method = "lm")



dta_vars_4mfa_2_wide_sel%>%
  ggplot(aes(tas_approx_z,log1p(mfa_z_sid_contrib_1 )))+
  geom_point()+
  ggpubr::stat_cor()+
  geom_smooth(method = "lm")


dta_vars_4mfa_2_wide_sel%>%
  ggplot(aes(aq2_approx_z,mfa_z_sid_contrib_1 ))+
  geom_point()+
  ggpubr::stat_cor()+
  geom_smooth(method = "lm")

```